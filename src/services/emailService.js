const SibApiV3Sdk = require('@sendinblue/client');

/**
 * Custom error class for email service related errors
 * @extends Error
 */
class EmailServiceError extends Error {
  /**
   * Create an EmailServiceError
   * @param {string} message - Error message
   * @param {string} code - Error code for categorization
   * @param {number|null} statusCode - HTTP status code if applicable
   * @param {Object|null} details - Additional error details
   */
  constructor(message, code, statusCode = null, details = null) {
    super(message);
    this.name = 'EmailServiceError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

/**
 * Brevo (formerly Sendinblue) email service for sending transcripts
 * Handles email delivery with retry logic, cost tracking, and error handling
 * @class
 */
class BrevoEmailService {
  /**
   * Initialize Brevo email service
   * @throws {Error} If BREVO_API_KEY is not configured
   */
  constructor() {
    this.apiKey = process.env.BREVO_API_KEY;
    this.fromEmail = process.env.BREVO_FROM_EMAIL || 'noreply@itinerary-whisperer.com';
    this.fromName = process.env.BREVO_FROM_NAME || 'Itinerary Whisperer';
    this.maxRetries = 3;
    this.baseDelay = 1000; // 1 second base delay for exponential backoff
    
    if (!this.apiKey) {
      throw new Error('BREVO_API_KEY environment variable is required');
    }
    
    // Initialize Brevo API client
    this.apiInstance = new SibApiV3Sdk.TransactionalEmailsApi();
    const apiKey = this.apiInstance.authentications['api-key'];
    apiKey.apiKey = this.apiKey;
    
    // Track email metrics
    this.metrics = {
      sent: 0,
      failed: 0,
      retries: 0,
      totalCost: 0
    };
  }

  /**
   * Format date for email subject line
   * @param {Date} [date=new Date()] - Date to format
   * @returns {string} Formatted date string for email subject
   */
  formatDate(date = new Date()) {
    const options = { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    };
    return date.toLocaleDateString('en-US', options);
  }

  /**
   * Calculate email cost based on Brevo pricing
   * Free tier: 300 emails/day
   * Paid: ~$0.00022 per email (based on starter plan)
   * @returns {number} Cost in USD for sending one email
   */
  calculateCost() {
    const dailyFreeLimit = 300;
    const costPerEmail = 0.00022;
    
    // Simple calculation - in production would track daily usage
    return this.metrics.sent > dailyFreeLimit ? costPerEmail : 0;
  }

  /**
   * Calculate exponential backoff delay for retries
   * @param {number} attempt - Current retry attempt (1-based)
   * @returns {number} Delay in milliseconds
   */
  getRetryDelay(attempt) {
    return this.baseDelay * Math.pow(2, attempt - 1);
  }

  /**
   * Send transcript email with retry logic and cost tracking
   * @param {string} recipientEmail - Email address to send transcript to
   * @param {string} transcriptText - Transcript content to send
   * @param {string} transcriptId - Unique identifier for the transcript
   * @returns {Promise<Object>} Email send result with delivery details
   * @throws {EmailServiceError} If email sending fails after all retries
   */
  async sendTranscript(recipientEmail, transcriptText, transcriptId) {
    let lastError = null;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        console.log(`Sending email attempt ${attempt}/${this.maxRetries} to ${recipientEmail}`);
        
        // Prepare email data
        const sendSmtpEmail = new SibApiV3Sdk.SendSmtpEmail();
        
        // Set sender
        sendSmtpEmail.sender = {
          email: this.fromEmail,
          name: this.fromName
        };
        
        // Set recipient
        sendSmtpEmail.to = [{
          email: recipientEmail
        }];
        
        // Set subject with date
        sendSmtpEmail.subject = `Your ${this.formatDate()} Discussion Transcript`;
        
        // Set plain text content
        sendSmtpEmail.textContent = `Here is your discussion transcript from ${this.formatDate()}:\n\n${transcriptText}\n\n---\nThis transcript was generated by Itinerary Whisperer\nTranscript ID: ${transcriptId}`;
        
        // Set HTML content (optional, using plain text for simplicity)
        sendSmtpEmail.htmlContent = `
          <html>
            <body style="font-family: Arial, sans-serif; color: #333;">
              <h2>Your Discussion Transcript</h2>
              <p>Here is your discussion transcript from ${this.formatDate()}:</p>
              <div style="background-color: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0;">
                <pre style="white-space: pre-wrap; font-family: 'Courier New', monospace;">${transcriptText}</pre>
              </div>
              <hr style="border: 1px solid #ddd; margin: 30px 0;">
              <p style="color: #666; font-size: 12px;">
                This transcript was generated by Itinerary Whisperer<br>
                Transcript ID: ${transcriptId}
              </p>
            </body>
          </html>
        `;
        
        // Add transcript as attachment
        const transcriptBuffer = Buffer.from(transcriptText, 'utf-8');
        sendSmtpEmail.attachment = [{
          content: transcriptBuffer.toString('base64'),
          name: `transcript-${transcriptId}.txt`,
          contentType: 'text/plain'
        }];
        
        // Add custom headers for tracking
        sendSmtpEmail.headers = {
          'X-Transcript-ID': transcriptId,
          'X-Service': 'Itinerary-Whisperer'
        };
        
        // Send email
        const startTime = Date.now();
        const response = await this.apiInstance.sendTransacEmail(sendSmtpEmail);
        const duration = Date.now() - startTime;
        
        // Update metrics
        this.metrics.sent++;
        const cost = this.calculateCost();
        this.metrics.totalCost += cost;
        
        // Log success
        console.log(`Email sent successfully to ${recipientEmail}`);
        console.log(`Response: MessageId=${response.messageId}, Duration=${duration}ms, Cost=$${cost.toFixed(4)}`);
        console.log(`Metrics: Sent=${this.metrics.sent}, Failed=${this.metrics.failed}, TotalCost=$${this.metrics.totalCost.toFixed(4)}`);
        
        // Return success response
        return {
          success: true,
          messageId: response.messageId,
          recipient: recipientEmail,
          sentAt: new Date(),
          cost: cost,
          duration: duration,
          attempt: attempt,
          provider: 'brevo'
        };
        
      } catch (error) {
        lastError = error;
        this.metrics.retries++;
        
        // Parse Brevo API error
        const statusCode = error.status || error.statusCode || 500;
        const errorMessage = error.response?.body?.message || error.message || 'Unknown error';
        const errorCode = error.response?.body?.code || 'BREVO_API_ERROR';
        
        console.error(`Email send attempt ${attempt} failed:`, {
          statusCode,
          errorCode,
          errorMessage,
          recipient: recipientEmail,
          transcriptId
        });
        
        // Check if error is retryable
        const isRetryable = statusCode >= 500 || statusCode === 429 || statusCode === 408;
        
        if (attempt < this.maxRetries && isRetryable) {
          const delay = this.getRetryDelay(attempt);
          console.log(`Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else if (!isRetryable) {
          // Non-retryable error, break the loop
          console.error('Non-retryable error encountered, stopping retries');
          break;
        }
      }
    }
    
    // All retries failed
    this.metrics.failed++;
    
    const finalError = new EmailServiceError(
      `Failed to send email after ${this.maxRetries} attempts: ${lastError.message}`,
      'EMAIL_SEND_FAILED',
      lastError.status || lastError.statusCode || 500,
      {
        recipient: recipientEmail,
        transcriptId,
        attempts: this.maxRetries,
        lastError: lastError.message
      }
    );
    
    throw finalError;
  }

  /**
   * Get current email service metrics and statistics
   * @returns {Object} Metrics object containing sent, failed, retry counts and costs
   */
  getMetrics() {
    return {
      ...this.metrics,
      avgCostPerEmail: this.metrics.sent > 0 ? this.metrics.totalCost / this.metrics.sent : 0
    };
  }

  /**
   * Validate email service configuration by testing API connection
   * @returns {Promise<boolean>} True if configuration is valid, false otherwise
   */
  async validateConfiguration() {
    try {
      // Test API key by getting account info
      const accountApi = new SibApiV3Sdk.AccountApi();
      const apiKey = accountApi.authentications['api-key'];
      apiKey.apiKey = this.apiKey;
      
      const account = await accountApi.getAccount();
      console.log('Brevo email service configured successfully');
      console.log(`Account: ${account.email}, Plan: ${account.plan[0].type}`);
      return true;
    } catch (error) {
      console.error('Brevo configuration validation failed:', error.message);
      return false;
    }
  }
}

// Export singleton instance
let emailService = null;

/**
 * Initialize the email service singleton
 * @returns {BrevoEmailService|null} Initialized email service or null if configuration missing
 */
function initializeEmailService() {
  try {
    if (!process.env.BREVO_API_KEY) {
      console.warn('BREVO_API_KEY not configured - email service disabled');
      return null;
    }
    
    emailService = new BrevoEmailService();
    emailService.validateConfiguration().catch(err => {
      console.error('Email service validation failed:', err);
    });
    
    return emailService;
  } catch (error) {
    console.error('Failed to initialize email service:', error.message);
    return null;
  }
}

/**
 * Get the email service singleton instance
 * @returns {BrevoEmailService|null} Email service instance or null if not initialized
 */
function getEmailService() {
  if (!emailService) {
    emailService = initializeEmailService();
  }
  return emailService;
}

module.exports = {
  initializeEmailService,
  getEmailService,
  EmailServiceError
};